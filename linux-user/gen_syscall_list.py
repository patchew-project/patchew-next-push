#
# Linux syscall table generator
# Copyright (c) 2018 Linaro, Limited.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, see <http://www.gnu.org/licenses/>.
#

from __future__ import print_function
import sys

# These are sets of all syscalls that have been converted.
# The lists are in collation order with '_' ignored.

# These syscalls are supported by all targets.
# Avoiding ifdefs for these can diagnose typos in $cpu/syscall_nr.h
unconditional_syscalls = [
    "clone",
    "close",
    "getgroups",
    "gettid",
    "mlock",
    "mlockall",
    "mprotect",
    "mremap",
    "msync",
    "munlock",
    "munlockall",
    "munmap",
    "name_to_handle_at",
    "openat",
    "open_by_handle_at",
    "pread64",
    "preadv",
    "pwrite64",
    "pwritev",
    "read",
    "readv",
    "setfsgid",
    "setfsuid",
    "setgid",
    "setgroups",
    "setsid",
    "setuid",
    "write",
    "writev",
]

# These syscalls are only supported by some target or abis.
conditional_syscalls = [
    "fork",
    "getegid",
    "getegid32",
    "geteuid",
    "geteuid32",
    "getgid",
    "getgid32",
    "getgroups32",
    "getpgrp",
    "getpid",
    "getppid",
    "getresgid",
    "getresgid32",
    "getresuid",
    "getresuid32",
    "getuid",
    "getuid32",
    "getxgid",
    "getxpid",
    "getxuid",
    "ipc",
    "mmap",
    "mmap2",
    "msgctl",
    "msgget",
    "msgrcv",
    "msgsnd",
    "open",
    "semctl",
    "semget",
    "semop",
    "setfsgid32",
    "setfsuid32",
    "setgid32",
    "setgroups32",
    "setregid",
    "setregid32",
    "setresgid",
    "setresgid32",
    "setresuid",
    "setresuid32",
    "setreuid",
    "setreuid32",
    "setuid32",
    "shmat",
    "shmctl",
    "shmdt",
    "shmget",
    "vfork",
]


def header(f):
    # Do not ifdef the declarations -- their use may be complicated.
    all = unconditional_syscalls + conditional_syscalls
    all.sort()
    for s in all:
        print("extern const SyscallDef def_", s, ";", sep = '', file = f)


def def_syscall(s, f):
    print("    case TARGET_NR_", s, ": return &def_", s, ";",
          sep = '', file = f);


def source(f):
    print("static const SyscallDef *syscall_table(int num)",
          "{",
          "    switch (num) {",
          sep = '\n', file = f)

    for s in unconditional_syscalls:
        def_syscall(s, f)
    for s in conditional_syscalls:
        print("#ifdef TARGET_NR_", s, sep = '', file = f)
        def_syscall(s, f)
        print("#endif", file = f)

    print("    }",
          "    return NULL;",
          "}",
          sep = '\n', file = f);


def main():
    p = sys.argv[1]
    f = open(p, "w")

    print("/* This file is autogenerated by gensyscall.py.  */\n\n",
          file = f)

    if p[len(p) - 1] == 'h':
        header(f)
    else:
        source(f)

    f.close();


main()
